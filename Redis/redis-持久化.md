## RDB
1. rdb就是每隔固定的一些时间将内存中的数据集写入快照，也就是snapshot快照
2. rbd工作方式：redis会完全复制主进程（变量、环境变量、程序计数器等），也就是fork一个子进程去进行持久化，会先把数据写入到一个临时文件中去，待持久化过程结束后，在用这个临时文件替换掉上次持久化后的文件，整个过程中不需要任何I/O操作，这就确保了极高的性能，如果需要大量的数据恢复，RBD比AOF效率更高，但是RBD最后的一次持久化的数据可能丢失
3. 如果存储一个数据后急需持久化，就用save命令，lastsave可以获取最后一个save的时间
4. 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。
5. bgsave也会产生快照
6. 如何恢复，把dump.rdb文件移动到安装目录，然后启动就可以了
7. 停止rdb：动态所有停止RDB保存规则的方法：redis-cli config set save ""

### 优势
（1）适合大数据量的恢复
（2）对数据的一致性要求没有那么高
### 劣势
（1）在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改，
（2）在fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑

## AOF
1. 以日志的形式来记录每个写操作，将Redis执行过的所有写指令以redis的协议(RESP协议)记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作，记录的是操作，Aof保存的是appendonly.aof文件
2. redis-check-aof --fix aof文件名 进行修复，如果aof文件有语法错误，这个命令可以检测
3. AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof
4. AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似
5. auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb 默认值 大生产环境会设置到G级别，aof文件大小超过这个值，会触发重写机制

### 优势
（1）每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好
（2）每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失
（3）不同步：appendfsync no 从不同步

### 劣势
（1）相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb
（2）aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同

## which one
1.RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储

2.AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议（RESP协议）追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大

3.只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.

4.同时开启：(1) 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,

因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.(2)RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。

5.性能总结：因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。

如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。

如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构