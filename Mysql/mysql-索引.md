
## 索引简介

### 索引的本质就是：索引一种数据结构  可以理解为：排好序的快速查找的数据结构

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，
这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：

左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址为了加快Col2的查找，**可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，**这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。

![upload successful](http://blogs.xinghe.host/images/pasted-17.png)

二叉树弊端之一：二叉树很可能会发生两边不平衡的情况。

> B-TREE: 多路查找树(B:balance)  会自动根据两边的情况自动调节，使两端无限趋近于平衡状态。可以使性能最稳定。(myisam使用的方式)
B-TREE弊端：(插入/修改操作多时，B-TREE会不断调整平衡，消耗性能)从侧面说明了索引不是越多越好。
B+TREE:Innodb 所使用的索引

我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引。**其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引**。当然，除了B+树这种类型的索引之外，还有**哈稀索引(hash index)**等。
### 索引的劣势：

- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息

- 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的，一般来说索引本身也很大，不可能全部存储在内存中，**因此索引往往以索引文件的形式存储的磁盘上**

### 索引的优势：

- 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗

## 索引的分类
### 主键索引 
 >设定为主键后数据库会自动建立索引，innodb为聚簇索引
 使用  AUTO_INCREMENT 关键字的列必须有索引(只要有索引就行)
### 单值索引
>即一个索引只包含单个列，一个表可以有多个单列索引
### 唯一索引
>索引列的值必须唯一，但允许有空值

**建立 唯一索引时必须保证所有的值是唯一的（除了null），若有重复数据，会报错<br> 唯一索引与主键索引的区别是主键索引不可以为null 唯一索引可以**
### 复合索引
>即一个索引包含多个列

## 索引的结构

### BTree索引 
> Myisam普通索引

![upload successful](http://blogs.xinghe.host/images/pasted-18.png)

#### 初始化介绍
一颗b树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，**如17、35并不真实存在于数据表中**。

#### 查找过程

- 如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。

- 真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

### B+Tree索引
>innodb的普通索引

B+TREE 第二级的 数据并不能直接取出来，只作索引使用。在内存有限的情况下，查询效率高于 BTREE

BTREE 第二级可以直接取出来，树形结构比较重，在内存无限大的时候有优势。

### B+Tree与BTree的区别

**B+Tree与B-Tree 的区别：结论在内存有限的情况下，B+TREE 永远比 B-TREE好。无限内存则后者方便**

- B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。(一次查询可能进行两次i/o操作)

- 在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。 

#### 思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？

-  B+树的磁盘读写代价更低 ，B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 

-  B+树的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### 聚簇索引与非聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值进错的存储在一起。
 如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。

#### 聚簇索引的好处

按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。

#### 聚簇索引的限制

对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。
由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键。
为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。（参考聚簇索引的好处。）

>这里说明了主键索引为何采用自增的方式：1、业务需求，有序。2、能使用到聚簇索引

### full-text全文索引

全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。

**不同于like方式的的：<br>**
SELECT * FROM article WHERE content LIKE ‘%查询字符串%’;
**全文索引用match+against方式查询：<br>**
SELECT * FROM article WHERE MATCH(title,content) AGAINST (‘查询字符串’);

明显的提高查询效率。

#### 限制
 - mysql5.6.4以前只有Myisam支持，5.6.4版本以后innodb才支持，但是官方版本不支持中文分词，需要第三方分词插件。
 - 5.7以后官方支持中文分词。随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solr,elasticSearch等专门的搜索引擎所替代。
 
### Hash索引
Hash索引只有Memory, NDB两种引擎支持，Memory引擎默认支持Hash索引，如果多个hash值相同，出现哈希碰撞，那么索引以链表方式存储。NoSql采用此中索引结构。
### R-Tree索引
R-Tree在mysql很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。相对于b-tree，r-tree的优势在于范围查找。

## 创建索引

### 那些字段需要创建索引

- 主键自动建立唯一索引
- 频繁作为查询条件的字段应该创建索引(where 后面的语句)
- 查询中与其它表关联的字段，外键关系建立索引：A 表关联 B 表：A join B    on 后面的连接条件 既 A 表查询 B 表的条件。所以 B 表被关联的字段建立索引能大大提高查询效率因为在 join 中，join 左边的表会用每一个字段去遍历 B 表的所有的关联数据，相当于一个查询操作
- 单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)
- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度：group by 和 order by 后面的字段有索引大大提高效率
- 查询中统计或者分组字段

### 那些字段不要创建索引：

- 表记录太少
- 经常增删改的表，Why:提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件
- Where条件里用不到的字段不创建索引
- 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。

## 索引优化

### 最左前缀

- 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。
- and 忽略左右关系。既即使没有按顺序 由于优化器的存在，会自动优化。经过试验结论  建立了 idx_nameAge 索引  id 为主键
  - 当使用覆盖索引的方式时，(select name/age/id from staffs where age=10 (后面没有其他没有索引的字段条件))，即使不是以 name 开头，也会使用 idx_nameAge 索引。<br>
  <!--more-->
   既 select 后的字段 有索引，where 后的字段也有索引，则无关执行顺序。
  - 除开上述条件 才满足最左前缀法则。
  
   EXPLAIN SELECT * FROM staffs WHERE age = 25 AND pos = 'dev';<br>
   EXPLAIN SELECT * FROM staffs WHERE pos = 'dev';
- 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描
- 存储引擎不能使用索引中范围条件右边的列
  -  where条件查找范围条件，type回事range 并且后面的where条件 索引失效
- 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *
  - 会用到index extra中 会using index 性能更好
- mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描
  - 索引  idx_nameAgeJob  idx_name
    - 使用 != 和 <> 的字段索引失效( != 针对数值类型。 <> 针对字符类型前提 where and 后的字段在混合索引中的位置比当前字段靠后  where age != 10 and name='xxx'  ,这种情况下，mysql自动优化，将 name='xxx' 放在 age ！=10 之前，name 依然能使用索引。只是 age 的索引失效)
- is not null 也无法使用索引,但是is null是可以使用索引的
- like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作
   - like ‘%abc%’ 或者 "%abc" type 类型会变成 all
   - like ‘abc%’ type 类型为 range ，算是范围，可以使用索引
   
#### 问题：解决like '%字符串%'时索引不被使用的方法？？

>利用覆盖索引去解决
  - select name,age,email from tables ... type会是index using index
  - select id from tables type也是index using index id是主键索引 也可以使用到
- 字符串不加单引号索引失效
  - 2000和‘2000’是不一样的，字符串类型的不可以不加单引号，mysql会底层进行转换导致索引失 效，使用了函数造成索引失效
- 少用or,用它来连接时会索引失效

### 总结
#### 顺口溜
- 带头大哥不能死（复合索引的最左前缀原则，最左边的索引不能没有，没有会导致索引失效）
- 中间兄弟不能断（复合索引中间的索引不能没有，否则索引只会生效第一个，后面的索引失效）
- 索引列上不计算（计算、函数、(自动or手动)类型转换）
- like百分加右边
- 范围后面全失效（范围查询后面的索引会失效）
- 字符串里有引号（mysql会底层进行转换导致索引失效）

#### 假设index(a,b,c) 复合索引Where语句索引是否被使用

- where a = 3     使用到a
- where a = 3 and b = 5      使用到a，b
- where a = 3 and b = 5 and c = 4    使用到a,b,c
- where b = 3 或者 where b = 3 and c = 4  或者 where c = 4 没用到
- where a = 3 and c = 5   使用到a， 但是c不可以，b中间断了
- where a = 3 and b > 4 and c = 5      使用到a和b， c不能用在范围之后，b后断了
- where a = 3 and b like 'kk%' and c = 4    使用到a,b, c 但是type为range
- where a = 3 and b like '%kk' and c = 4     只用到a
- where a = 3 and b like '%kk%' and c = 4     只用到a
- where a = 3 and b like 'k%kk%' and c = 4   使用到a,b,c 但是type为range 同7
#### 一般性建议
- 对于单键索引，尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。(避免索引过滤性好的索引失效)
- 在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引
- 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的
#### sql优化步骤
- 观察，至少跑一天，然后看看生产的慢sql的情况
- 开启慢查询日志，超过设定慢查询时间的，抓取出来
- explain+慢sql分析 （会解决80%）
- show profile 查询sql在mysql服务器中的执行细节和生命周期情况
- 运维 or DBA 进行sql数据库的数据库服务器参数调优