## 前言

这是一道很有意思的面试题，可以考察一个人的全面能力，和“一条url从输入到浏览器后都做了什么”这道题一样经典

## 分析

首先分析问题，为什么慢，有两方面原因

1. 这条sql平时执行的很快，偶尔会很慢
2. 这条sql一直执行的就很慢

### 这条sql平时执行的很快，偶尔会很慢

1. 阻塞等待拿到锁，在数据库十分繁忙的时候，我们需要一些资源的时候要加锁，但是锁被别人占用了，只能等待别人释放锁，所以sql变慢，这时候可以执行show processlist 查看是否有大量的sql阻塞

2. 遇到了高并发的场景，因为mysql的持久化并不是立即持久化，而是都写到了一个叫redo log的文件中，等到redo log被写满了之后，就会把文件内容刷到磁盘上去，其他sql就会阻塞，等待redo log持久化完毕，所以sql会变慢

### 这条sql一直执行就很慢

这才是这个问题的重点，mysql开启慢日志的话，超过long_query_time这个配置时间后，这条sql就会被定义为慢语句，会被记录到slow_query_log_file配置的慢语句日志中，这时候就要分析我们的sql了

1. explain 查询计划，查询我们sql的执行效率，有没有用到索引，有没有用到临时表排序等等，都会大大降低我们的sql效率，type字段需要达到ref或者range级别，这样的sql才算得上比较不错的sql，并且在extra中不能出现比如using temporary产生临时表或者 filesort 文件排序，这样的sql效率非常地下，explain的列格式可以参考我之前写的一篇博客：http://xinghe.art/post/2d2b618b.html

2. 如果没有索引，我们要适当的添加索引，比如在经常查询的列上面添加索引，然后，如果有索引但是没有用到，就要调整我们的sql语句，比如联合索引没有符合最左前缀原则，索引就会失效，导致全盘扫描

3. mysql的优化器会帮我们决定使用哪个索引，系统是通过索引的区分度来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为基数，即区分度越高，基数越大。

>系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过采样的方式，来预测索引的基数的。

    扯了这么多，重点的来了，居然是采样，那就有可能出现失误的情况，也就是说，一个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。
	然后就呵呵，系统就不走索引了，直接走全部扫描了。
	所以呢，说了这么多，得出结论：由于统计的失误，导致系统没有走索引，而是走了全表扫描，而这，也是导致我们 SQL 语句执行的很慢的原因。
    
    
 ## 参考
 
 https://www.cnblogs.com/luyucheng/p/6265594.html
 http://www.matools.com/blog/190432671