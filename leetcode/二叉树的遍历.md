## 二叉树前序遍历
### 递归
```
func qianxu(root *TreeNode) []int{
    res := []int{}
    dfs(root,res)
    return res
}

func dfs(root *TreeNode,res *[]int){
    if root == nil {
        return
    }
    *res = append(*res,root.Val)
    dfs(root.Left,res)
    dfs(root.Right,res)
}
```
### 迭代

```$xslt
func qianxu(root *TreeNode) []int{
	if root == nil {
        return []int{}
    }
    stack := []*TreeNode{}
    res := []int{}
    for len(stack) > 0 || root != nil {
        for root != nil {
            res = append(res,root.Val)
            stack = append(stack,root)
            root = root.Left
        }
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        root = node.Right
    }
    return res
}
```

## 二叉树的中序遍历
### 递归
```$xslt
func zhongxu(root *TreeNode) []int{
    res := []int{}
    dfs(root,res)
    return res
}

func dfs(root *TreeNode,res *[]int){
    if root == nil {
        return
    }
    
    dfs(root.Left,res)
    *res = append(*res,root.Val)
    dfs(root.Right,res)
}
```
### 迭代
```$xslt

func zhongxu(root *TreeNode) []int{
	if root == nil {
        return []int{}
    }
    stack := []*TreeNode{}
    res := []int{}
    for root != nil || len(stack) > 0 {

        for root != nil {
            stack = append(stack,root)
            root = root.Left
        }

        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        res = append(res,node.Val)
        root = node.Right
    }
    return res
}

```


## 二叉树的后序遍历
### 递归
```$xslt
func houxu(root *TreeNode) []int{
    res := []int{}
    dfs(root,res)
    return res
}

func dfs(root *TreeNode,res *[]int){
    if root == nil {
        return
    }
    dfs(root.Left,res)
    dfs(root.Right,res)
    *res = append(*res,root.Val)
}
```
### 迭代
```$xslt
func houxu(root *TreeNode) []int{
	if root == nil {
		return []int{}
	}
	stack := []*TreeNode{}
	res := []int{}
	var lastVisit *TreeNode
	for root != nil || len(stack) > 0 {
		for root != nil {
			stack = append(stack,root)
			root = root.Left
		}
		// 先拿出来，不弹出
		node := stack[len(stack)-1]
		// 根节点必须在右节点弹出之后，再弹出
		if node.Right == nil || node.Right == lastVisit {
			stack = stack[:len(stack)-1]
			res = append(res,node.Val)
			lastVisit = node
		}else{
			root = node.Right
		}
	}
	return res
}    
```