## 本地事务

先不说分布式事务，我们来说说事务是什么意思

事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。

简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制。

事务一般都有ACID的特性

- A:原子性(Atomicity)，一个事务中的操作为一个原子操作，不可再分割，要么全部执行，要不全部不执行
	- 打个比方，你买东西，要么交钱发货，要么发不出货就退钱
- C:一致性(Consistency),表示事务不会破坏关系型数据库的完整性，在事务执行前和执行后数据库都要处于一致性的状态
- I:隔离性(Isolation),数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）
	- 打个比方，你买东西不能影响其他人
- D:持久性(Durability)，指事务执行后数据会永远保存下来，即使系统崩溃，也可以修复回来
	- 打个比方，你买东西老板会记账，最后老板忘记来也有账本可以查看

### 本地事务隔离级别

因为有并发访问数据库的情况，会出现以下的情况

1. 更新丢失：事务a修改一条数据为100，事务2同时修改数据为200，然后两个事务先后提交，那么其中一个事务的修改就会丢失，就成为更新丢失

2. 脏读：数据库在执行事务的过程中，事务a可以读取到事务b未提交的修改，这时事务b事务回滚了，那么事务a读取的就是脏数据

3. 不可重复读：事务a在事务期间一直在修改一条数据，而事务b在这时也一直查询这条数据，这时候会出现事务a修改为100、修改为200、修改为300等等情况，但是事务b在同一个事务期间读取这条数据得到了不同的结果，这就是不可重复读

4. 幻读：幻读其实跟不可重复读很相似，幻读是事务a在事务期间**批量**修改数据从1修改为2，但是事务b在此时插入了一条数据为1的数据，事务a这时再次检查数据发现有一条1的数据，此时好像发生了幻觉一样。与不可重复读的区别在于数据的量，不可重复读是针对一条数据，而幻读针对多条数据

这四种情况分别有隔离级别，未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）

- 未提交读（Read uncommitted）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果，**会出现脏读的情况**
- 提交读（read committed）：会出现不可重复读的情况，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 **也支持所谓的不可重复读（Nonrepeatable Read）**，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果
- 可重复读（repeatable read）：**这是mysql默认的隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：**幻读 （Phantom Read）**
	innodb是利用**MVCC 多版本并发控制**来解决幻读的
- 串行化（Serializable）：最高的隔离级别，所有事务串行执行，并发行很差，  

### innodb实现原理

innodb实现事务的原理是利用了本地资源管理器

事务的 ACID 是通过 InnoDB 日志和锁来保证。

事务的隔离性是通过数据库锁的机制实现的，持久性通过 Redo Log（重做日志）来实现，原子性和一致性通过 Undo Log 来实现。

- Undo Log：事务开始之前会先把数据备份到Undo Log中，如果事务中发生了 回滚操作，就把Undo Log里面的数据恢复就行了
- Redo Log：与Undo Log相反，当事务成功的时候，会把数据记录到Redo Log中去，不是把数据持久化，当系统崩溃了，虽然数据没有持久化，但是 Redo Log 已经持久化，恢复Redo Log中的数据就行了

## 分布式事务

分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。

简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。

本质上来说，分布式事务就是为了保证不同数据库的数据一致性。


### 分布式事务产生的原因

分为两个原因

1. service多节点
	- 随着系统架构的复杂度升级，我们会把一些服务单独部署，并分配不同的团队去维护，但是有些操作需要两个或者多个系统保持一致，这就需要分布式事务了，比如优惠券和积分，只能使用分布式事务来保证优惠券发放来之后积分一定要扣减
2. resource多节点
	- 同样的，互联网发展得太快了，我们的 MySQL 一般来说装用户钱包的数据就得进行分库分表。对于一个支付宝的转账业务来说，你给朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。

### 分布式事务的基础

#### CAP理论

- C:一致性,这里的c和ACID的一样，意思是不同节点的数据，当其中一个节点数据更新后，其他节点可以读取更新后的内容，就是强一致性，反之就是分布式不一致
- A:可用性，这里的A和ACID的A就不一样了，可用性就是非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。
- P:分区容错性，当出现网络分区后，系统能够继续工作。打个比方，这里集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。

CAP理论就是三者一定不能共存，但是分布式系统中，P分区容错性又是必须的，所以就分为了AP和CP两种方案

CP就是放弃可用性而追求强一致性和分区容错性，ZooKeeper就是这种架构

AP就是放弃一致性而追求可用性和分区容错性，这也是大部分分布式系统的选择，后面的BASE就是根据AP扩展的

同时 CAP 中选择两个，比如你选择了 CP，并不是叫你放弃 A。因为 P 出现的概率实在是太小了，大部分的时间你仍然需要保证 CA。

就算分区出现了你也要为后来的 A 做准备，比如通过一些日志的手段，使其他机器恢复至可用。

#### BASE

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写，是对 CAP 中 AP 的一个扩展。

- 基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。

- 软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。

- 最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。

BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。

BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。

## 分布式事务解决方案

### 你是否真的需要分布式事务

你是否真的需要分布式事务？

分布式事务是因为微服务过多而引出的，不管用哪种方案，都会增加系统架构的复杂性，我建议是把分布式事务聚集到一个服务器上来执行，转化为本地事务，不要为了追求某种设计而引入不必要的成本和复杂度。

### 2PC(XA协议)

XA协议由Tuxedo首先提出的，并交给X/Open组织，作为资源管理器（数据库）与事务管理器的接口标准

意思是两阶段提交，Mysql5.5实现了XA 协议，但是有bug，在mysql5.7.7版本修复

1. 事务管理器要求每个涉及到事务的数据库进行预提交(precommit)操作，确定是否可以提交
2. 事务管理器要求每个数据库进行提交操作，或者回滚操作

优点：尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现

缺点：
- 单点问题，事务管理者在其中担任很重要的角色，一但挂掉就完蛋了。。。，比如此时完成了第一阶段的precommit，准备第二节点的提交，但是事务管理者挂了，资源管理器就会一直阻塞，导致数据库无法使用。
- 同步阻塞：在准备就绪后，资源管理者就会一直阻塞，直到提交完成，释放资源
- 数据不一致：虽然两阶段提交是为了强一致性所设计，但是依然有数据不一致的情况：
	- 比如在第二阶段提交的过程中，加入事务管理者发出了commit命令，但因为网络问题只有一部分资源管理者收到，并进行了提交，其余一部分没有收到通知，一直处于阻塞的状态，导致了数据不一致

总的来说XA协议实现简单，并且大部分主流数据库都实现了，不需要自己实现

#### MySQL XA 的限制

在MySQL 5.7.7 之前，MySQL一直存在一个"bug"。在事务达到PREPARED状态后，客户端断开与MySQL的连接，MySQL 会自动回滚该事务，这个行为不符合分布式事务的规范，MySQL将PREPARED的事务丢失了。之所以MySQL这么实现是因为MySQL 5.7.7 之前PREPARED的事务并不会记录到binlog中。客户端退出后会丢失该信息，如果允许再提交，那么binlog缺少事务信息，会造成主从不一致。

在MySQL 5.7.7 之后，MySQL 新增了一个XA_prepare_log_event的事件，会把xa start到xa prepare中间的操作记录到Binlog中。Slave读取Relay log 进行回放，当SQL Thread读取到PREPARED的事务后，在读取xa commit或者xa rollback前，会进行一个类似客户端断开的操作，继续读取后续的事务信息，不会阻塞SQL Thread的执行。从以上的结果看，Oracle在MySQL 5.7.7 上确实完美的解决了MySQL XA一直存在的一个"bug"。

### 三阶段提交

三阶段提交是把两阶段提交的准备阶段再次分为两个阶段了，有兴趣的同学可以自己研究一下：
参考：https://segmentfault.com/a/1190000012534071

### TCC

try-confirm-cancle 

TCC 事务机制相比于上面介绍的 XA，解决了如下几个缺点：

- 单点为题：由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
- 阻塞问题：引入了超时，超时后进行补偿，并且不会锁定资源，将资源转换为业务逻辑形式，粒度更小
- 数据不一致：有了补偿机制，由业务活动管理器控制一致性

对于TCC的解释：

1. Try阶段：尝试执行，完成所有业务的检查(一致性)，预留必须业务资源(准隔离性)
2. Confirm阶段：确认真正执行业务，不做任何业务检查，只是用Try阶段所预留的业务资源，Confirm满足幂等性，要求操作具备幂等性，Confirm失败后进行重试
3. Cancle阶段：取消执行，释放Try阶段所预留的业务资源，Cancle满足幂等性，失败后与Confirm基本一样，

TCC适合一些需要保持强一致性的、并且执行时间较短的业务

实现参考：https://github.com/liuyangming/ByteTCC/。

### 本地消息列表

>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。

大致意思是把事务写到一个本地消息列表，然后有一个专门的定时任务去轮询这个消息列表，把没处理过的消息分发到相应系统去处理，然后对应的系统先把事务写进自己的本地事务列表，然后处理并更新消息的状态

对于一些异常未处理的消息，先查看是否已经处理，然后再重新发送，到对应的系统后先检查是否已经处理，如果已经接收，再判断是否执行，如果执行在马上又进行通知事务；如果未执行，需要重新执行由业务保证幂等

就举用 100 元去买一瓶水的例子。

1. 当你扣钱的时候，需要在你扣钱的服务器上面新增一个消息列表，把你扣钱和减库存放到一个事务里面(利用本地事务保证一致性)，写到本地消息列表中
2. 这时候又一个专门的定时任务去扫描这个消息列表，把没有执行的消息发给商品服务器，商品服务器接收到这个消息后，首先写入商品服务器的消息列表，然后进行扣减，扣减成功后，更新事务表中的状态
3. 商品服务器通过定时扫描消息表或者直接通知扣钱服务器，扣钱服务器在本地消息列表中更新状态
4. 针对一些异常情况，定时扫描未处理成功的消息，进行重新发送，商品服务器接收到消息之后，首先判断是否是重复的，如果已经接受，判断是否执行，如果执行，再马上通知事务；如果未执行，需要重新执行由业务保证幂等，也就是不会多扣一瓶水

本地消息队列是 BASE 理论，是最终一致模型，适用于对一致性要求不高的情况。实现这个模型时需要注意重试的幂等。

### MQ 事务

MQ事务是对本地消息列表的一个封装，将本地消息列表移动到MQ中，具体实现参考：
https://www.jianshu.com/p/453c6e7ff81c

简单介绍下流程

1. 第一阶段 Prepared 消息，会拿到消息的地址。
2. 第二阶段执行本地事务。
3. 第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。

如果确认消息失败，在 RocketMQ Broker 中提供了定时扫描没有更新状态的消息。

如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在 RocketMQ 中是以 Listener 的形式给发送者，用来处理。

如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这时就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失。

## 参考

- https://segmentfault.com/a/1190000012534071
- https://developer.51cto.com/art/201808/581174.htm
- https://www.kancloud.cn/kancloud/theory-of-mysql-index/41850