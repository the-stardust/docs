## 前言

分布式系统少不了的就是分布式锁，现在市面上有几种常见的分布式锁的实现方式

- 基于数据库的锁，利用唯一键约束
- 基于redis的两种模式，一种RedLock，另一种SetNx
- 基于zookeeper的临时有序节点，或者临时znode


## 基于数据库


利用数据表的唯一键约束，加锁的时候就插入一个唯一值，其他线程加锁会插入失败，就等于没有拿到锁，释放锁就是把这个条记录删掉就行

优点：操作简单、容易理解

缺点：
- 性能开销太大
- 有单点问题、需要有备份数据库，挂了之后迅速切换
- 没有失效时间，需要额外起一个进程去扫表，定时清理过期的锁


不推荐这种，应该也没有人会使用这种方案，

## 基于redis

### RedLock

redis官方给的有两种分布式锁的方案，其中一个就是RedLock

基于redis-cluster，比如有5个redis master实例，获取锁的步骤是
- 获取当前毫秒时间戳
- 轮流尝试在每个master上创建锁，过期时间较短，一般为几十毫秒
- 尝试在大多数节点上监理所，5个节点的要求是3个(超过一半)
- 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算成功
- 要是建立锁失败了，就一次把之前建立好的锁给删除
- 只要别人建立了一把分布式锁，你就得**不断轮询去尝试获取锁**

### 普通方式

利用redis里面的命令
			
            SET key value [EX seconds] [PX milliseconds] NX
- NX表示只有key不存在的时候才设置成功，如果已存在这个key，就会设置失败，返回nil
- EX seconds 设置过期时间，秒级，过期自动释放
- PX 设置过期时间，毫秒级

例如创建一把锁的命令是：

			SET resource_name my_random_value PX 30000 NX
            
释放锁的话，就是删除key，但是需要判断下value是不是你的，因为有可能存在一种情况就是，当前获取锁的进程，执行了一个时间很长的任务，这时候锁已经被redis自动释放了，其他进程已经获取到了一个锁，当这个进程去删除key的时候，就会把其他进程设置的key给删除了，所以要校验一下value是不是自己的

可以使用lua脚本删除

		-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。
	if redis.call("get",KEYS[1]) == ARGV[1] then
    	return redis.call("del",KEYS[1])
	else
    	return 0
	end

### 总结

redis也会有单点问题，所以RedLock需要redis-cluster集群来支持，但是比较复杂，当你没有获取到锁的时候，你需要不断的去尝试获取锁

## 基于zookeeper

zk分布式锁，zk真是个好组件，

分布式框架的协调中心，例如在分布式系统中a系统处理完消息需要告知b系统，可以用zk来实现

分布式系统的配置中心，dubbo的注册中心就是用的zk

HA高可用，很多的大数据系统的高可用就是用zk来实现的，hadoop、hdfs等，主进程挂了会立马通过zk感知到切换到备用进程

分布式锁：就是接下来讲的

### 简单锁

创建一个znode，当其他节点创建的时候，就会创建失败，只能**注册个监听器**监听这个锁

释放锁就是删除这个znode，监听器就会立马感知，然后通知已经等待的客户端


### 临时有序节点

如果一把锁创建成功了，还有其他人想获取，此时多个人就会排队，注册一个**监听前面一个人的监听器**

当一个人释放锁的时候，同时监听器就会通知排在他后面的一个人，后面的那个人就会获取到锁了


### 总结

两种方式，第二种比较友好，第一种相当于各凭本事，但是有点类似linux惊群效应，一个进程释放锁，其他进程全部去抢，只有一个进程可以获取到锁，其他进程继续休眠，开销比第二种大，第二种就是先到先得，我用完你再有。。。


## 总结

三种方案，首先就是推荐zookeeper，因为数据库方案基本没人去用，因为你的系统都用到了分布式锁了，并发量肯定不小，你再给数据库点压力，岂不是火上浇油


redis方案胜在简单，大多数人肯定是熟悉redis的，不管你是不是分布式系统、高并发什么的，小项目里面也会用到redis，所以优点就是操作简单、大多数人比较熟悉

但是redis 分布式锁大家没发现好麻烦吗？遍历上锁，计算时间等等......zk 的分布式锁语义清晰实现简单。

另外一点就是，如果是 Redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。

所以先不分析太多的东西，就说这几点，我个人实践认为 zk 的分布式锁比 Redis 的分布式锁牢靠、而且模型简单易用。